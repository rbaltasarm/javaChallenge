package com.javachallenge.entity;

import java.util.HashSet;
import java.util.Set;
import javax.persistence.Column;
import javax.persistence.Entity;
import javax.persistence.GeneratedValue;
import javax.persistence.GenerationType;
import javax.persistence.Id;
import javax.persistence.JoinColumn;
import javax.persistence.JoinTable;
import javax.persistence.ManyToMany;
import javax.persistence.NamedAttributeNode;
import javax.persistence.NamedEntityGraph;
import javax.persistence.NamedEntityGraphs;
import javax.persistence.Table;
import org.hibernate.annotations.NaturalId;
import org.springframework.util.Assert;

/** Represents an user and their relationships.
 * @author Baltasar
 * @version 1.1
*/


//NamedEntityGraphs to avoid laizy inizialization issue with manytomany relations
@Table( name="tbl_users")
@NamedEntityGraphs({
    @NamedEntityGraph(name = "friendOf-entityGraph", 
        attributeNodes = {@NamedAttributeNode("friendOf")}),
     @NamedEntityGraph(name = "friends-entityGraph", 
        attributeNodes = {@NamedAttributeNode("friends")})})
@Entity
public class User {

        //The userName is defined as unique
        @NaturalId
        @Column(name = "name")
	private String name;	
    
        //Internal id. Autogenerated
        @Id
        @GeneratedValue(strategy = GenerationType.AUTO)
        @Column(name="id")
	private Long id;
        
       
        //This relation represents the connections with other users that have been 
        //stablished by the user itself (I connect to....)
        @ManyToMany
        @JoinTable(name="tbl_connections",  
            joinColumns=@JoinColumn(name="user_id"),
            inverseJoinColumns=@JoinColumn(name="conected_to_id")
        )
        private Set<User> friends;
        
        //This relation represents the connections that have been stablished with 
        //the current user by other users (I have been connected to...)
        @ManyToMany
        @JoinTable(name="tbl_connections",
            joinColumns=@JoinColumn(name="conected_to_id"),
            inverseJoinColumns=@JoinColumn(name="user_id")
        )
        private Set<User> friendOf;
	
        
        
        
	protected User() {
               this.friendOf= new HashSet();
               this.friends = new HashSet();
	}

	public User(String name) {
            Assert.hasLength(name, "User name can not be empty");
            Assert.isTrue(name.length()<20, "User name lenght has to be lower than 20");
            Assert.isTrue(name.split(" ").length==1, "User name has to be an unique word");
            this.name = name;
	    this.friendOf= new HashSet();
            this.friends = new HashSet();	
	}

	public Long getId() {
		return id;
	}

	public String getName() {
		return name;
	}

	public void setName(String name) {
		this.name = name;
	}

        

	@Override
	public int hashCode() {
		return id == null ? 0 : id.hashCode();
	}

        //maybe later we need to compare using ignore case names    
	@Override
	public boolean equals(Object obj) {
		if (this == obj)
			return true;
		if (obj == null)
			return false;
		if (getClass() != obj.getClass())
			return false;
		User other = (User) obj;
		if (id == null) {
			if (other.id != null)
				return false;
		} else if (!id.equals(other.id))
			return false;
		return true;
	}

       public void addFriend(User friend){
           this.friends.add(friend);
       }
       
       public Set<User> getFriends(){
           return this.friends;
       }
       
       public Set<User> getFriendOf(){
           return this.friendOf;
       }
       
       
       public void setFriendOf(Set<User> friendOf){
           this.friendOf=friendOf;
       }
       public void setFriends(Set<User> friends){
           this.friends=friends;
       }
	
}
